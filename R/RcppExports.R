# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Add mutations manually from R.
#'
#' Note that all indices are in 0-based C++ indexing. This means that the first
#' item is indexed by `0`, and so forth.
#'
#' @param vs_ External pointer to a C++ `VarSet` object
#' @param var_ind Integer index to the desired variant. Uses 0-based indexing!
#' @param seq_ind Integer index to the desired sequence. Uses 0-based indexing!
#' @param nucleo nucleo Character to substitute for existing one.
#' @param new_pos_ Integer index to the desired subsitution location.
#'     Uses 0-based indexing!
#'
#' @name add_mutations
NULL

#' Turns a VarGenome's mutations into a list of data frames.
#'
#' Temporary function for testing.
#'
#'
#' @noRd
#'
see_mutations <- function(vs_, var_ind) {
    .Call(`_gemino_see_mutations`, vs_, var_ind)
}

#' Add a substitution.
#'
#' @inheritParams vs_ add_mutations
#' @inheritParams var_ind add_mutations
#' @inheritParams seq_ind add_mutations
#' @param nucleo nucleo Character to substitute for existing one.
#' @inheritParams new_pos_ add_mutations
#'
#' @describeIn add_mutations
#'
add_substitution <- function(vs_, var_ind, seq_ind, nucleo, new_pos_) {
    invisible(.Call(`_gemino_add_substitution`, vs_, var_ind, seq_ind, nucleo, new_pos_))
}

#' Add an insertion.
#'
#' @inheritParams vs_ add_mutations
#' @inheritParams var_ind add_mutations
#' @inheritParams seq_ind add_mutations
#' @param nucleos_ Nucleotides to insert at the desired location.
#' @inheritParams new_pos_ add_mutations
#'
#' @describeIn add_mutations
#'
add_insertion <- function(vs_, var_ind, seq_ind, nucleos_, new_pos_) {
    invisible(.Call(`_gemino_add_insertion`, vs_, var_ind, seq_ind, nucleos_, new_pos_))
}

#' Add a deletion.
#'
#' @inheritParams vs_ add_mutations
#' @inheritParams var_ind add_mutations
#' @inheritParams seq_ind add_mutations
#' @param size_ Size of deletion.
#' @inheritParams new_pos_ add_mutations
#'
#' @describeIn add_mutations
#'
add_deletion <- function(vs_, var_ind, seq_ind, size_, new_pos_) {
    invisible(.Call(`_gemino_add_deletion`, vs_, var_ind, seq_ind, size_, new_pos_))
}

#' Merge a reference genome into a single sequence.
#'
#'
#' @param ref_ An external pointer (R class \code{externalptr}) to a
#'     \code{RefGenome} class in C++ (the full class in C++ is
#'     \code{Rcpp::XPtr<RefGenome>}).
#'
#' @return Nothing. Changes are made in place.
#'
#' @name merge_sequences
#'
#' @noRd
#'
merge_sequences <- function(ref_) {
    invisible(.Call(`_gemino_merge_sequences`, ref_))
}

#' Filter reference genome sequences by size or for a proportion of total nucleotides.
#'
#'
#' @param ref_ An external pointer (R class \code{externalptr}) to a
#'     \code{RefGenome} class in C++ (the full class in C++ is
#'     \code{Rcpp::XPtr<RefGenome>}).
#' @param min_seq_size Integer minimum sequence size to keep.
#'     Defaults to \code{0}, which results in this argument being ignored.
#' @param out_seq_prop Numeric proportion of total sequence to keep.
#'     Defaults to \code{0}, which results in this argument being ignored.
#'
#' @return Nothing. Changes are made in place.
#'
#' @name filter_sequences
#'
#' @noRd
#'
#'
filter_sequences <- function(ref_, min_seq_size = 0L, out_seq_prop = 0) {
    invisible(.Call(`_gemino_filter_sequences`, ref_, min_seq_size, out_seq_prop))
}

#' Create `RefGenome` pointer based on nucleotide equilibrium frequencies.
#'
#' Function to create random sequences for a new reference genome object.
#'
#' Note that this function will never return empty sequences.
#'
#' @param n_seqs Number of sequences.
#' @param len_mean Mean for the gamma distribution for sequence sizes.
#' @param len_sd Standard deviation for the gamma distribution for sequence sizes.
#' @param equil_freqs Vector of nucleotide equilibrium frequencies for
#'     "A", "C", "G", and "T", respectively. Defaults to `rep(0.25, 4)`.
#' @param n_cores Number of cores to use via OpenMP.
#'
#'
#' @return External pointer to a `RefGenome` C++ object.
#'
#' @export
#'
#' @examples
#'
#' genome <- create_genome(10, 100e6, 10e6, pis = c(0.1, 0.2, 0.3, 0.4))
#'
create_genome <- function(n_seqs, len_mean, len_sd, equil_freqs = numeric(0), n_cores = 1L) {
    .Call(`_gemino_create_genome`, n_seqs, len_mean, len_sd, equil_freqs, n_cores)
}

#' Create random sequences.
#'
#' Function to create random sequences into character vector format or for a new
#' reference genome object.
#'
#' Note that this function will not return empty sequences.
#'
#' @inheritParams create_genome
#'
#' @return Character vector of sequence strings.
#'
#' @noRd
#'
#' @export
#'
#' @examples
#' randos <- rando_seqs(10, 1000, 10)
#'
rando_seqs <- function(n_seqs, len_mean, len_sd, equil_freqs = numeric(0), n_cores = 1L) {
    .Call(`_gemino_rando_seqs`, n_seqs, len_mean, len_sd, equil_freqs, n_cores)
}

#' Internal C++ function to digest all sequences for all variants in a variant set.
#'
#'
#'
#' @param var_ An external pointer to a C++ \code{VarSet} object
#'     representing variants from the reference genome.
#' @param bind_sites Vector of enzyme full recognition site(s).
#' @param len5s A vector of the numbers of characters of the prime5 sites for each
#'     recognition site.
#' @param chunk_size The size of chunks to divide sequences into when digesting.
#' @param n_cores The number of cores to use for processing.
#'
#' @return A list of lists, each sub-list containing multiple vectors representing
#'     the locations of cut sites for a given variant on a given sequence.
#'     Indexing the output list would be done as such:
#'     \code{output_list[[variant_index]][[sequence_index]][position_index]}.
#'
#' @noRd
#'
digest_var <- function(var_, bind_sites, len5s, chunk_size, n_cores) {
    .Call(`_gemino_digest_var`, var_, bind_sites, len5s, chunk_size, n_cores)
}

#' Internal C++ function to digest all sequences in a reference genome.
#'
#'
#'
#' @param ref_ An external pointer to a C++ \code{RefGenome} object
#'     representing the reference genome.
#' @param bind_sites Vector of enzyme full recognition site(s).
#' @param len5s A vector of the numbers of characters of the prime5 sites for each
#'     recognition site.
#' @param n_cores The number of cores to use for processing. This value is ignored
#'     if the input reference genome is merged and \code{chunk_size == 0}.
#'     Defaults to \code{1}.
#' @param chunk_size Size of chunks to break sequences into for processing.
#'     This value is ignored if it's set to zero.
#'     Ideally this is set to a value that results in a number of chunks divisible by
#'     the number of cores you're using, and is most useful when `n_cores` is greater
#'     than the number of scaffolds.
#'     Breaking into increasingly small chunks results in increasing overhead, so
#'     beware of making this argument very small.
#'     Reference genome sequences are not copied during this function, so using
#'     this argument for a reference genome does NOT decrease memory usage
#'     appreciably.
#'     Defaults to \code{0}.
#'
#' @return A list of vectors, each vector representing the locations of cut sites
#'     on a given sequence.
#'     Indexing the output list would be done as such:
#'     \code{output_list[[sequence_index]][position_index]}.
#'
#' @noRd
#'
digest_ref <- function(ref_, bind_sites, len5s, n_cores = 1L, chunk_size = 0L) {
    .Call(`_gemino_digest_ref`, ref_, bind_sites, len5s, n_cores, chunk_size)
}

#' Function to print info on a `RefGenome`.
#'
#' Access `RefGenome` class's print method from R.
#'
#' @noRd
#'
print_rg <- function(rg_) {
    invisible(.Call(`_gemino_print_rg`, rg_))
}

#' Function to print info on a VarSet.
#'
#' Access `VarSet` class's print method from R.
#'
#' @noRd
#'
print_vs <- function(vs_) {
    invisible(.Call(`_gemino_print_vs`, vs_))
}

#' Read a non-indexed fasta file to a \code{RefGenome} object.
#'
#' @param file_name File name of the fasta file.
#' @param cut_names Boolean for whether to cut sequence names at the first space.
#'     Defaults to \code{TRUE}.
#' @param remove_soft_mask Boolean for whether to remove soft-masking by making
#'    sequences all uppercase. Defaults to \code{TRUE}.
#'
#' @return Nothing.
#'
#' @noRd
#'
read_fasta_noind <- function(fasta_file, cut_names, remove_soft_mask) {
    .Call(`_gemino_read_fasta_noind`, fasta_file, cut_names, remove_soft_mask)
}

#' Read an indexed fasta file to a \code{RefGenome} object.
#'
#' @param file_name File name of the fasta file.
#' @param remove_soft_mask Boolean for whether to remove soft-masking by making
#'    sequences all uppercase. Defaults to \code{TRUE}.
#' @param offsets Vector of sequence offsets from the fasta index file.
#' @param names Vector of sequence names from the fasta index file.
#' @param lengths Vector of sequence lengths from the fasta index file.
#' @param line_lens Vector of sequence line lengths from the fasta index file.
#'
#' @return Nothing.
#'
#' @noRd
#'
#'
read_fasta_ind <- function(fasta_file, fai_file, remove_soft_mask) {
    .Call(`_gemino_read_fasta_ind`, fasta_file, fai_file, remove_soft_mask)
}

#' Write \code{RefGenome} to an uncompressed fasta file.
#'
#' @param file_name File name of output fasta file.
#' @param ref_ An external pointer to a \code{RefGenome} C++ object.
#' @param text_width The number of characters per line in the output fasta file.
#'
#' @return Nothing.
#'
#' @noRd
#'
#'
write_fasta_fa <- function(file_name, ref_, text_width) {
    invisible(.Call(`_gemino_write_fasta_fa`, file_name, ref_, text_width))
}

#' Write \code{RefGenome} to a compressed fasta file.
#'
#' @inheritParams write_fasta_fa
#'
#' @return Nothing.
#'
#' @noRd
#'
write_fasta_gz <- function(file_name, ref_, text_width) {
    invisible(.Call(`_gemino_write_fasta_gz`, file_name, ref_, text_width))
}

#' Make a VarSet object from a set of sequences and # variants
#'
#' @noRd
make_vars <- function(seqs, n_vars) {
    .Call(`_gemino_make_vars`, seqs, n_vars)
}

#' Function to piece together the strings for all sequences in a VarGenome.
#'
#' @noRd
see_vg <- function(vs_, v) {
    .Call(`_gemino_see_vg`, vs_, v)
}

#' See all sequence sizes in a VarSet object.
#'
#' @noRd
see_sizes <- function(vs_, v) {
    .Call(`_gemino_see_sizes`, vs_, v)
}

make_ref <- function(input) {
    .Call(`_gemino_make_ref`, input)
}

see_ref_seq <- function(ref_, s) {
    .Call(`_gemino_see_ref_seq`, ref_, s)
}

#' Get a reference genome sequence's name.
#'
#' Temporary function for testing.
#'
#'
#' @noRd
#'
see_ref_name <- function(ref_, s) {
    .Call(`_gemino_see_ref_name`, ref_, s)
}

#' Get a reference genome sequence's size.
#'
#' Temporary function for testing.
#'
#'
#' @noRd
#'
see_ref_seq_size <- function(ref_, s) {
    .Call(`_gemino_see_ref_seq_size`, ref_, s)
}

#' Get number of sequences in a reference genome.
#'
#' Temporary function for testing.
#'
#'
#' @noRd
#'
see_ref_n_seq <- function(ref_) {
    .Call(`_gemino_see_ref_n_seq`, ref_)
}

#' Make a string uppercase in place.
#'
#' The version of this function exported to R was ~4x faster than R's
#' `.Internal(toupper(...))`, and keeping it in C++ is surely even faster.
#'
#' @param input_str An input string to be changed.
#'
#' @return Nothing. Changes are made in place.
#'
#' @noRd
#'
NULL

#' Merge a vector of strings into one.
#'
#'
#' @param in_strings Character vector of strings to merge.
#'
#' @return A single string.
#'
#' @noRd
#'
cpp_merge_str <- function(in_strings) {
    .Call(`_gemino_cpp_merge_str`, in_strings)
}

#' Split a string based on a single-character delimiter
#'
#'
#' @param in_string A string to split.
#' @param split Character to split string by.
#'
#' @noRd
#'
cpp_str_split_delim <- function(in_string, split) {
    .Call(`_gemino_cpp_str_split_delim`, in_string, split)
}

#' Pr(S == s).
#'
#'
#' @noRd
NULL

#' Pr(S <= s)
#'
#' @noRd
#'
NULL

#' var(S).
#'
#' @noRd
#'
NULL

#' Expected value of S.
#'
#' If comparing distances to S, remember that S in Vitter's paper is the number of
#' positions to skip _before_ taking the next one, so it should be 1 less than the
#' distance.
#' So just add 1 to this function to get expected distances.
#'
#' @noRd
#'
NULL

#' "Algorithm D" for fast sampling without replacement.
#'
#' This algorithm is from the following paper:
#' Vitter, Jeffrey Scott. 1984. Faster methods for random sampling. Communications of
#'     the ACM 27:703–718.
#'
#' @param input_vec A vector of unsigned integers (class `arma::uvec` or
#'     `std::vector<uint>`) of length `n`.
#'     Sampling will generate `n` random numbers. `n` should always be <= N.
#' @param N The population size. The sampling will generate numbers from
#'     `0` to `(N - 1)`.
#' @param engine A sitmo PRNG engine.
#' @param n2N A numeric threshold placed on the algorithm used to find new locations.
#'     This is not recommended to be changed. Defaults to 50.
#' @param alpha A numeric threshold placed on the algorithm used to find new locations.
#'     This is not recommended to be changed. Defaults to 0.8.
#'
#'
#'
#'
#' @noRd
#'
#'
NULL

test_vitter_d <- function(reps, n, N, seeds, n2N = 50, alpha = 0.8) {
    .Call(`_gemino_test_vitter_d`, reps, n, N, seeds, n2N, alpha)
}

