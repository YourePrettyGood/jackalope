# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#'
#' Create a SequenceSet from vectors for sequences and sequence names
#'
#' @param sequences Character vector of sequences.
#' @param seq_names Character vector of sequence names.
#'
#' @return A pointer to a \code{SequenceSet} class in C++ (class \code{Rcpp::XPtr}).
#'
#'
SequenceSet_characters <- function(sequences, seq_names, merged = TRUE) {
    .Call(`_gemino_SequenceSet_characters`, sequences, seq_names, merged)
}

total_size_SequenceSet <- function(ss) {
    .Call(`_gemino_total_size_SequenceSet`, ss)
}

seq_sizes_SequenceSet <- function(ss) {
    .Call(`_gemino_seq_sizes_SequenceSet`, ss)
}

one_nucleo_SequenceSet <- function(ss, scaff, pos) {
    .Call(`_gemino_one_nucleo_SequenceSet`, ss, scaff, pos)
}

one_scaff_SequenceSet <- function(ss, scaff) {
    .Call(`_gemino_one_scaff_SequenceSet`, ss, scaff)
}

is_merged_SequenceSet <- function(ss) {
    .Call(`_gemino_is_merged_SequenceSet`, ss)
}

seq_names_SequenceSet <- function(ss) {
    .Call(`_gemino_seq_names_SequenceSet`, ss)
}

all_scaff_gc_SequenceSet <- function(ss) {
    .Call(`_gemino_all_scaff_gc_SequenceSet`, ss)
}

one_scaff_gc_SequenceSet <- function(ss, seq_name) {
    .Call(`_gemino_one_scaff_gc_SequenceSet`, ss, seq_name)
}

one_range_gc_SequenceSet <- function(ss, seq_name, start, stop) {
    .Call(`_gemino_one_range_gc_SequenceSet`, ss, seq_name, start, stop)
}

mult_ranges_gc_SequenceSet <- function(ss, seq_names, starts, stops) {
    .Call(`_gemino_mult_ranges_gc_SequenceSet`, ss, seq_names, starts, stops)
}

#'
#' Create a new SequenceSet from an existing one's pointer.
#'
#' @param input Input sequence set object.
#'
#' @return A pointer to a \code{SequenceSet} class in C++ (class \code{Rcpp::XPtr}).
#'
#'
SequenceSet_copy <- function(input) {
    .Call(`_gemino_SequenceSet_copy`, input)
}

SummarizeSequenceSet <- function(ss, console_width) {
    invisible(.Call(`_gemino_SummarizeSequenceSet`, ss, console_width))
}

#'
#' Create a VariantSet from input vectors.
#'
#' Note: The estimate of total segregating sites will be underestimated because
#' it counts all insertions as one site, even if they're > 1 bp long.
#'
#' @param nucleos A list of character vectors, each string representing all the
#'     nucleotides present at segregating sites for a particular variant on a
#'     particular scaffold.
#' @param sites A list of integer vectors, each vector representing all the
#'     segregating sites among all variants for one scaffold.
#' @param scaffold_lengths A list of numeric or integer vectors, each vector
#'     representing all the scaffold lengths for a particular variant.
#'
#'
#' @return A pointer to a \code{VariantSet} class in C++ (class \code{Rcpp::XPtr}).
#'
#'
VariantSet_vectors <- function(nucleos, sites, scaffold_lengths) {
    .Call(`_gemino_VariantSet_vectors`, nucleos, sites, scaffold_lengths)
}

n_variants_VS <- function(vs) {
    .Call(`_gemino_n_variants_VS`, vs)
}

total_segr_sites_VS <- function(vs) {
    .Call(`_gemino_total_segr_sites_VS`, vs)
}

nucleos_VS <- function(vs, variant_index, scaff_index) {
    .Call(`_gemino_nucleos_VS`, vs, variant_index, scaff_index)
}

sites_VS <- function(vs, variant_index, scaff_index) {
    .Call(`_gemino_sites_VS`, vs, variant_index, scaff_index)
}

scaffold_length_VS <- function(vs, variant_index, scaff_index) {
    .Call(`_gemino_scaffold_length_VS`, vs, variant_index, scaff_index)
}

#'
#' Create a new VariantSet from an existing one's pointer.
#'
#' @param input Input variant set object.
#'
#' @return A pointer to a \code{VariantSet} class in C++ (class \code{Rcpp::XPtr}).
#'
#'
VariantSet_copy <- function(input) {
    .Call(`_gemino_VariantSet_copy`, input)
}

variants_retr_scaff <- function(scaff_num, variant_num, ss, vs) {
    .Call(`_gemino_variants_retr_scaff`, scaff_num, variant_num, ss, vs)
}

variants_retr_seq <- function(start_pos, length_out, scaff_num, variant_num, ss, vs) {
    .Call(`_gemino_variants_retr_seq`, start_pos, length_out, scaff_num, variant_num, ss, vs)
}

variants_retr_var <- function(variant_num, ss, vs) {
    .Call(`_gemino_variants_retr_var`, variant_num, ss, vs)
}

SummarizeVariantSet <- function(vs) {
    invisible(.Call(`_gemino_SummarizeVariantSet`, vs))
}

#' Merge a reference genome into a single sequence.
#'
#'
#' @param ref_ An external pointer (R class \code{externalptr}) to a
#'     \code{RefGenome} class in C++ (the full class in C++ is
#'     \code{Rcpp::XPtr<RefGenome>}).
#'
#' @return Nothing. Changes are made in place.
#'
#' @name merge_sequences
#'
#'
merge_sequences <- function(ref_) {
    invisible(.Call(`_gemino_merge_sequences`, ref_))
}

#' Filter reference genome sequences by size or for a proportion of total nucleotides.
#'
#'
#' @param ref_ An external pointer (R class \code{externalptr}) to a
#'     \code{RefGenome} class in C++ (the full class in C++ is
#'     \code{Rcpp::XPtr<RefGenome>}).
#' @param min_seq_size Integer minimum sequence size to keep.
#'     Defaults to \code{0}, which results in this argument being ignored.
#' @param out_seq_prop Numeric proportion of total sequence to keep.
#'     Defaults to \code{0}, which results in this argument being ignored.
#'
#' @return Nothing. Changes are made in place.
#'
#' @name filter_sequences
#'
#'
filter_sequences <- function(ref_, min_seq_size = 0L, out_seq_prop = 0) {
    invisible(.Call(`_gemino_filter_sequences`, ref_, min_seq_size, out_seq_prop))
}

#' Internal C++ function to digest all sequences for all variants in a variant set.
#'
#'
#'
#' @param reference An external pointer to a C++ \code{SequenceSet} object
#'     representing the reference genome
#'     (also the \code{variants} object's \code{reference} field).
#' @param variant_set An external pointer to a C++ \code{VariantSet} object
#'     representing the variants' deviations from the reference genome
#'     (also the \code{variants} object's \code{variant_set} field).
#' @param bind_sites Vector of enzyme full recognition site(s).
#' @param len5s A vector of the numbers of characters of the prime5 sites for each
#'     recognition site.
#' @param chunk_size The size of chunks to divide sequences into when digesting.
#' @param n_cores The number of cores to use for processing.
#'
#' @return A list of lists, each sub-list containing multiple vectors representing
#'     the locations of cut sites for a given variant on a given sequence.
#'     Indexing the output list would be done as such:
#'     \code{output_list[[variant_index]][[sequence_index]][position_index]}.
#'
#'
digest_var <- function(var_, bind_sites, len5s, chunk_size, n_cores) {
    .Call(`_gemino_digest_var`, var_, bind_sites, len5s, chunk_size, n_cores)
}

#' Internal C++ function to digest all sequences in a reference genome.
#'
#' This function shouldn't be exported after testing is finished.
#'
#'
#' @param ref_ An external pointer to a C++ \code{RefGenome} object
#'     representing the reference genome.
#' @param bind_sites Vector of enzyme full recognition site(s).
#' @param len5s A vector of the numbers of characters of the prime5 sites for each
#'     recognition site.
#' @param n_cores The number of cores to use for processing. This value is ignored
#'     if the input reference genome is merged and \code{chunk_size == 0}.
#'     Defaults to \code{1}.
#' @param chunk_size Size of chunks to break sequences into for processing.
#'     This value is ignored if it's set to zero.
#'     Ideally this is set to a value that results in a number of chunks divisible by
#'     the number of cores you're using, and is most useful when `n_cores` is greater
#'     than the number of scaffolds.
#'     Breaking into increasingly small chunks results in increasing overhead, so
#'     beware of making this argument very small.
#'     Reference genome sequences are not copied during this function, so using
#'     this argument for a reference genome does NOT decrease memory usage
#'     appreciably.
#'     Defaults to \code{0}.
#'
#' @return A list of vectors, each vector representing the locations of cut sites
#'     on a given sequence.
#'     Indexing the output list would be done as such:
#'     \code{output_list[[sequence_index]][position_index]}.
#'
#' @export
#'
digest_ref <- function(ref_, bind_sites, len5s, n_cores = 1L, chunk_size = 0L) {
    .Call(`_gemino_digest_ref`, ref_, bind_sites, len5s, n_cores, chunk_size)
}

make_ref <- function(input) {
    .Call(`_gemino_make_ref`, input)
}

see_ref <- function(ref_) {
    invisible(.Call(`_gemino_see_ref`, ref_))
}

get_ref_seq <- function(ref_, s) {
    .Call(`_gemino_get_ref_seq`, ref_, s)
}

#' Get a reference genome sequence's name.
#'
#' Temporary function for testing.
#'
#'
#' @noRd
#'
get_ref_name <- function(ref_, s) {
    .Call(`_gemino_get_ref_name`, ref_, s)
}

#' Get a reference genome sequence's size.
#'
#' Temporary function for testing.
#'
#'
#' @noRd
#'
get_ref_seq_size <- function(ref_, s) {
    .Call(`_gemino_get_ref_seq_size`, ref_, s)
}

#' Get number of sequences in a reference genome.
#'
#' Temporary function for testing.
#'
#'
#' @noRd
#'
get_ref_n_scaff <- function(ref_) {
    .Call(`_gemino_get_ref_n_scaff`, ref_)
}

#' Make a VarSet object from a set of sequences and # variants
#'
#'
#' @noRd
#'
make_vars <- function(seqs, n_vars) {
    .Call(`_gemino_make_vars`, seqs, n_vars)
}

#' Function to piece together the strings for all sequences in a VarGenome.
#'
#' Temporary function for testing.
#'
#'
#' @noRd
#'
see_vg <- function(vs_, v) {
    .Call(`_gemino_see_vg`, vs_, v)
}

#' Function to print info on a VarSet.
#'
#' Temporary function for testing.
#'
#'
#' @noRd
#'
print_vs <- function(vs_) {
    invisible(.Call(`_gemino_print_vs`, vs_))
}

#' Turns a VarGenome's mutations into a list of data frames.
#'
#' Temporary function for testing.
#'
#'
#' @noRd
#'
see_mutations <- function(vs_, v) {
    .Call(`_gemino_see_mutations`, vs_, v)
}

#' See all scaffold sizes in a VarSet object.
#'
#' Temporary function for testing.
#'
#'
#' @noRd
#'
see_sizes <- function(vs_, v) {
    .Call(`_gemino_see_sizes`, vs_, v)
}

#' View the starting portion of a variant sequence.
#'
#' Temporary function for testing.
#'
#'
#' @noRd
#'
see_start <- function(vs_, v, scaff, size_) {
    .Call(`_gemino_see_start`, vs_, v, scaff, size_)
}

#' View a chunk of a variant sequence.
#'
#' Temporary function for testing.
#'
#'
#' @noRd
#'
see_chunk <- function(vs_, v, scaff, start, chunk_size) {
    .Call(`_gemino_see_chunk`, vs_, v, scaff, start, chunk_size)
}

#' Add many mutations (> 1,000) to a VarSet object from R.
#'
#' I made this fxn for testing bc running add_* (which goes from R to C++) many
#' times gives segfault when including deletions.
#' `min_muts` and `max_muts` give range of # mutations per variant sequence.
#'
#' Temporary function for testing.
#'
#'
#' @noRd
#'
many_mutations <- function(vs_, min_muts, max_muts) {
    invisible(.Call(`_gemino_many_mutations`, vs_, min_muts, max_muts))
}

read_fasta_noind <- function(fasta_file, cut_names, remove_soft_mask) {
    .Call(`_gemino_read_fasta_noind`, fasta_file, cut_names, remove_soft_mask)
}

read_fasta_ind <- function(fasta_file, fai_file, remove_soft_mask) {
    .Call(`_gemino_read_fasta_ind`, fasta_file, fai_file, remove_soft_mask)
}

write_fasta_fa <- function(file_name, ref_, text_width) {
    invisible(.Call(`_gemino_write_fasta_fa`, file_name, ref_, text_width))
}

write_fasta_gz <- function(file_name, ref_, text_width) {
    invisible(.Call(`_gemino_write_fasta_gz`, file_name, ref_, text_width))
}

#' Weighted sampling of a digested \code{dna_set}'s fragment sizes.
#'
#' See \code{size_filter.Rmd} vignette for more information on the sampling scheme and
#' the justification for it.
#'
#' Each index present in the output from this function indicates to keep the
#' fragment \emph{preceding} the cut site at that index.
#' For example, if you have the following conditions:
#' \enumerate{
#'   \item The second scaffold for your focal genome consists of the following
#'     sequence: \code{"AACCGGTT"}.
#'   \item The digestion cut sites for this scaffold are at positions \code{0},
#'     \code{3}, and \code{5}.
#'   \item The output from this function for this scaffold is \code{1}.
#' }
#'
#' ... then you'd keep the fragment from index \code{0} to index \code{2}: \code{"AAC"}.
#'
#' \emph{Note:} All indices are in C++ 0-based format.
#'
#'
#' @param all_digests A list of vectors of digestion cut sites, one vector per scaffold.
#' @param reference A \code{dna_set} object's \code{sequence_set} field, which
#'     represents genome information.
#' @param n_cores Number of cores to use for processing. This argument is ignored if
#'     OpenMP is not enabled. Defaults to 1.
#' @param increment The width of fragment sizes to group together when calculating
#'      the availability probability. Defaults to 1.
#'
#' @return A list of vectors of indices for the fragment sizes that were selected.
#'
filter_reference_frags <- function(all_digests, reference, n_cores = 1L, increment = 1L) {
    .Call(`_gemino_filter_reference_frags`, all_digests, reference, n_cores, increment)
}

#' Weighted sampling of a digested \code{variants}'s fragment sizes.
#'
#' See \code{size_filter.Rmd} vignette for more information on the sampling scheme and
#' the justification for it.
#'
#' Each index present in the output from this function indicates to keep the
#' fragment \emph{preceding} the cut site at that index.
#' For example, if you have the following conditions:
#' \enumerate{
#'   \item The second scaffold for your focal genome consists of the following
#'     sequence: \code{"AACCGGTT"}.
#'   \item The digestion cut sites for this scaffold are at positions \code{0},
#'     \code{3}, and \code{5}.
#'   \item The output from this function for this scaffold is \code{1}.
#' }
#'
#' ... then you'd keep the fragment from index \code{0} to index \code{2}: \code{"AAC"}.
#'
#' \emph{Note:} All indices are in C++ 0-based format.
#'
#'
#' @param all_digests A list of lists of vectors of digestion cut sites, one
#'     vector for each unique scaffold--variant combination.
#' @param reference A \code{variants} object's \code{reference} field, which
#'     represents genome information.
#' @param variant_set A \code{variants} object's \code{variant_set} field, which
#'     represents information on variants' deviations from the reference genome.
#' @param n_cores Number of cores to use for processing. This argument is ignored if
#'     OpenMP is not enabled. Defaults to 1.
#' @param increment The width of fragment sizes to group together when calculating
#'      the availability probability. Defaults to 1.
#'
#' @return A list of lists of vectors of indices for the fragment sizes that
#'     were selected.
#'
filter_variants_frags <- function(all_digests, reference, variant_set, n_cores = 1L, increment = 1L) {
    .Call(`_gemino_filter_variants_frags`, all_digests, reference, variant_set, n_cores, increment)
}

#' Split one string into a vector of strings of the same size.
#'
#' \emph{Note}: This function is not exported to R.
#'
#' \emph{Note}: The last string may be of a different length if
#'     \code{in_string.length() / n != round(in_string.length() / n)}.
#'
#' @param in_string Input string to split.
#' @param n Size of strings to output.
#'
#' @return Vector of strings of the same size.
#'
#' @name cpp_str_split_int
#'
NULL

#' Make a string uppercase in place.
#'
#' This is ~4x faster than R's .Internal(toupper(...))
#'
#' @param input_str An input string.
#'
#' @return Output string of all uppercase letters.
#'
to_upper <- function(input_str) {
    .Call(`_gemino_to_upper`, input_str)
}

#' Make a string from a vector of integers.
#'
#'
#'
#' @param in_vec A vector of unsigned, 8-bit integers.
#'
#' @return A string.
#'
#'
uvec_to_str <- function(in_uvec) {
    .Call(`_gemino_uvec_to_str`, in_uvec)
}

#' Make a string from a 1-column matrix of integers.
#'
#'
#' @param in_vec A 1-column matrix of unsigned, 8-bit integers.
#'
#' @return A string.
#'
#'
ucol_to_str <- function(in_ucol) {
    .Call(`_gemino_ucol_to_str`, in_ucol)
}

#' Make a vector of integers from a string.
#'
#'
#' @param in_str A string.
#'
#' @return A vector of unsigned, 8-bit integers.
#'
#'
str_to_uvec <- function(in_str) {
    .Call(`_gemino_str_to_uvec`, in_str)
}

#' Make a 1-column matrix of integers from a string.
#'
#'
#' @param in_str A string.
#'
#' @return A 1-column matrix of unsigned, 8-bit integers.
#'
#'
str_to_ucol <- function(in_str) {
    .Call(`_gemino_str_to_ucol`, in_str)
}

#' Merge a vector of strings into one.
#'
#'
#' @param in_strings Character vector of strings to merge.
#'
#' @return A single string.
#'
#'
cpp_merge_str <- function(in_strings) {
    .Call(`_gemino_cpp_merge_str`, in_strings)
}

#' Create random sequences.
#'
#' Function to create random sequences into character vector format for or for a new
#' reference genome object.
#'
#' Note that this function will not return sequences smaller than 10bp.
#'
#' @param N Number of sequences.
#' @param mean_len Mean length of each sequence.
#' @param mean_len Standard deviation of lengths.
#' @param min_len Minimum length of any sequence. Defaults to \code{1}.
#'
#' @return Character vector of sequence strings.
#'
#' @export
#'
#' @examples
#' randos <- rando_seqs(1000)
#'
rando_seqs <- function(N, mean_len = 100, sd_len = 0, min_len = 1) {
    .Call(`_gemino_rando_seqs`, N, mean_len, sd_len, min_len)
}

#' Create RefGenome pointer based on nucleotide equilibrium frequencies.
#'
#' Function to create random sequences into character vector format for or for a new
#' reference genome object.
#'
#' Note that this function will never return empty sequences.
#'
#' @param N Number of sequences.
#' @param mean_ Mean for the gamma distribution for sequence sizes.
#' @param sd_ Standard deviation for the gamma distribution for sequence sizes.
#' @param Vector of nucleotide equilibrium frequencies for "A", "C", "G", and "T",
#'     respectively. Defaults to \code{rep(0.25, 4)}.
#'
#' @return Character vector of sequence strings.
#'
#' @export
#'
#' @examples
#'
#' genome <- create_genome(10, 100e6, 10e6, pis = c(0.1, 0.2, 0.3, 0.4))
#'
create_genome <- function(N, mean_, sd_, equil_freqs = numeric(0), n_cores = 1L) {
    .Call(`_gemino_create_genome`, N, mean_, sd_, equil_freqs, n_cores)
}

optim_prob <- function(v, mean_pws_, dens_, seg_div_) {
    .Call(`_gemino_optim_prob`, v, mean_pws_, dens_, seg_div_)
}

#' Randomly choose scaffolds for segregating sites, weighted based on scaffold length.
#'
#' This function is used separately for indels and SNPs.
#'
#' The indices of the output matrix coincide with the order of scaffolds in the
#' \code{dna_set} input to \code{make_variants}.
#'
#' This function does NOT return an error if a scaffold is chosen more times
#' than its length.
#'
#' @param total_mutations The total number of mutations (SNPs and indels).
#' @param scaff_lens A vector of cumulative sums of scaffold lengths.
#'
#'
#' @return A numeric vector containing the number of mutations per scaffold.
#'
sample_scaffs <- function(total_mutations, scaff_lens_cumsum, seeds) {
    .Call(`_gemino_sample_scaffs`, total_mutations, scaff_lens_cumsum, seeds)
}

#' Get possible nucleotide distributions and their pairwise differences.
#'
#' Retrieve all combinations (with replacement) of nucleotide distributions that sum
#' to \code{N}, and, for each, calculate \eqn{\pi_{ji}}.
#'
#'
#' @param N Total number of individuals the frequencies must add to.
#'
#' @return List consisting of a matrix and a vector.
#'     The matrix (\code{List$combos}) contains all nucleotide frequencies that add
#'     to \code{N} (by row).
#'     The vector (\code{List$mean_pws}) contains the mean pairwise differences
#'     for a segregating site comprised of nucleotide frequencies present in each row
#'     of the matrix.
#'     For example, a segregating site for 10 haploid samples containing 3 As, 3 Cs,
#'     2 Gs, and 2 Ts would have a mean pairwise difference of 0.8222222.
#'
cpp_nt_freq <- function(N) {
    .Call(`_gemino_cpp_nt_freq`, N)
}

#' Inner function to create a C++ \code{VariantSet} object
#'
#' A \code{VariantSet} object constitutes the majority of information in a
#' \code{variants} object (other than the reference genome) and is located in
#' the \code{variant_set} field.
#'
#' @param n_mutations Integer vector of the total number of mutations (SNPs or indels)
#'     for each scaffold.
#' @param reference External pointer to a C++ \code{SequenceSet} object that
#'     represents the reference genome.
#' @param snp_combo_mat Matrix of all possible nucleotide combinations among all
#'     variants per SNP.
#' @param snp_probs_cumsum Vector of sampling probabilities for each row in
#'     \code{snp_combo_mat}.
#' @param seeds Vector of seeds, the length of which dictates how many cores will be
#'     used.
#' @param snp_p Proportion of mutations that are SNPs. Defaults to 0.9.
#' @param insertion_p Proportion of \emph{indels} that are insertions. Defaults to 0.5.
#' @param n2N A numeric threshold placed on the algorithm used to find new locations.
#'     This is not recommended to be changed. Defaults to 50.
#' @param alpha A numeric threshold placed on the algorithm used to find new locations.
#'     This is not recommended to be changed. Defaults to 0.8.
#'
#'
#' @return An external pointer to a \code{VariantSet} object in C++.
#'
make_variant_set <- function(n_mutations, reference, snp_combo_mat, snp_probs_cumsum, seeds, snp_p = 0.9, insertion_p = 0.5, n2N = 50, alpha = 0.8) {
    .Call(`_gemino_make_variant_set`, n_mutations, reference, snp_combo_mat, snp_probs_cumsum, seeds, snp_p, insertion_p, n2N, alpha)
}

f_s <- function(s_vec, n, N) {
    .Call(`_gemino_f_s`, s_vec, n, N)
}

F_s <- function(s_vec, n, N) {
    .Call(`_gemino_F_s`, s_vec, n, N)
}

variance_s <- function(n, N) {
    .Call(`_gemino_variance_s`, n, N)
}

expected_s <- function(n, N) {
    .Call(`_gemino_expected_s`, n, N)
}

test_vitter_d <- function(reps, n, N, seeds, n2N = 50, alpha = 0.8) {
    .Call(`_gemino_test_vitter_d`, reps, n, N, seeds, n2N, alpha)
}

