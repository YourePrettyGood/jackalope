# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Merge a reference genome into a single sequence.
#'
#'
#' @param ref_genome_ptr An external pointer (R class \code{externalptr}) to a
#'     \code{RefGenome} class in C++ (the full class in C++ is
#'     \code{Rcpp::XPtr<RefGenome>}).
#'
#' @return Nothing. Changes are made in place.
#'
#' @name merge_sequences
#'
#' @noRd
#'
merge_sequences <- function(ref_genome_ptr) {
    invisible(.Call(`_jackal_merge_sequences`, ref_genome_ptr))
}

#' Filter reference genome sequences by size or for a proportion of total nucleotides.
#'
#'
#' @inheritParams ref_genome_ptr merge_sequences
#' @param min_seq_size Integer minimum sequence size to keep.
#'     Defaults to \code{0}, which results in this argument being ignored.
#' @param out_seq_prop Numeric proportion of total sequence to keep.
#'     Defaults to \code{0}, which results in this argument being ignored.
#'
#' @return Nothing. Changes are made in place.
#'
#' @name filter_sequences
#'
#' @noRd
#'
#'
filter_sequences <- function(ref_genome_ptr, min_seq_size = 0L, out_seq_prop = 0) {
    invisible(.Call(`_jackal_filter_sequences`, ref_genome_ptr, min_seq_size, out_seq_prop))
}

#' Replace Ns with randome nucleotides.
#'
#'
#' @return Nothing. Changes are made in place.
#'
#' @name replace_Ns_cpp
#'
#' @noRd
#'
#'
replace_Ns_cpp <- function(ref_genome_ptr, pi_tcag, n_cores, show_progress) {
    invisible(.Call(`_jackal_replace_Ns_cpp`, ref_genome_ptr, pi_tcag, n_cores, show_progress))
}

#' Create `RefGenome` pointer based on nucleotide equilibrium frequencies.
#'
#' Function to create random sequences for a new reference genome object.
#'
#' Note that this function will never return empty sequences.
#'
#' @param n_seqs Number of sequences.
#' @param len_mean Mean for the gamma distribution for sequence sizes.
#' @param len_sd Standard deviation for the gamma distribution for sequence sizes.
#'     If set to `<= 0`, all sequences will be the same length.
#' @param pi_tcag Vector of nucleotide equilibrium frequencies for
#'     "T", "C", "A", and "G", respectively.
#' @param n_cores Number of cores to use via OpenMP.
#'
#'
#' @return External pointer to a `RefGenome` C++ object.
#'
#' @noRd
#'
#' @examples
#'
#'
create_genome_ <- function(n_seqs, len_mean, len_sd, pi_tcag, n_cores) {
    .Call(`_jackal_create_genome_`, n_seqs, len_mean, len_sd, pi_tcag, n_cores)
}

#' Create random sequences as a character vector.
#'
#' This function is used internally for testing.
#'
#'
#' @inheritParams create_genome
#'
#' @return Character vector of sequence strings.
#'
#'
#' @noRd
#'
rando_seqs <- function(n_seqs, len_mean, len_sd = 0, pi_tcag = numeric(0), n_cores = 1L) {
    .Call(`_jackal_rando_seqs`, n_seqs, len_mean, len_sd, pi_tcag, n_cores)
}

#' Illumina sequence for reference object.
#'
#'
#' @noRd
#'
illumina_ref_cpp <- function(ref_genome_ptr, paired, matepair, out_prefix, compress, n_reads, prob_dup, n_cores, show_progress, read_chunk_size, frag_len_shape, frag_len_scale, frag_len_min, frag_len_max, qual_probs1, quals1, ins_prob1, del_prob1, qual_probs2, quals2, ins_prob2, del_prob2, barcodes) {
    invisible(.Call(`_jackal_illumina_ref_cpp`, ref_genome_ptr, paired, matepair, out_prefix, compress, n_reads, prob_dup, n_cores, show_progress, read_chunk_size, frag_len_shape, frag_len_scale, frag_len_min, frag_len_max, qual_probs1, quals1, ins_prob1, del_prob1, qual_probs2, quals2, ins_prob2, del_prob2, barcodes))
}

#' Illumina sequence for reference object.
#'
#'
#' @noRd
#'
illumina_var_cpp <- function(var_set_ptr, paired, matepair, out_prefix, compress, n_reads, prob_dup, n_cores, show_progress, read_chunk_size, variant_probs, frag_len_shape, frag_len_scale, frag_len_min, frag_len_max, qual_probs1, quals1, ins_prob1, del_prob1, qual_probs2, quals2, ins_prob2, del_prob2, barcodes) {
    invisible(.Call(`_jackal_illumina_var_cpp`, var_set_ptr, paired, matepair, out_prefix, compress, n_reads, prob_dup, n_cores, show_progress, read_chunk_size, variant_probs, frag_len_shape, frag_len_scale, frag_len_min, frag_len_max, qual_probs1, quals1, ins_prob1, del_prob1, qual_probs2, quals2, ins_prob2, del_prob2, barcodes))
}

#' Used below to directly make a MutationTypeSampler
#'
#' @noRd
#'
NULL

#' Add mutations at segregating sites for one sequence from coalescent simulation output.
#'
#' @noRd
#'
NULL

make_mutation_sampler_base <- function(Q, pi_tcag, insertion_rates, deletion_rates) {
    .Call(`_jackal_make_mutation_sampler_base`, Q, pi_tcag, insertion_rates, deletion_rates)
}

make_mutation_sampler_chunk_base <- function(Q, pi_tcag, insertion_rates, deletion_rates, chunk_size) {
    .Call(`_jackal_make_mutation_sampler_chunk_base`, Q, pi_tcag, insertion_rates, deletion_rates, chunk_size)
}

#' Add mutations at segregating sites from coalescent simulation output.
#'
#' @noRd
#'
add_coal_sites_cpp <- function(ref_genome_ptr, var_names, seg_sites, Q, pi_tcag, insertion_rates, deletion_rates, n_cores, show_progress) {
    .Call(`_jackal_add_coal_sites_cpp`, ref_genome_ptr, var_names, seg_sites, Q, pi_tcag, insertion_rates, deletion_rates, n_cores, show_progress)
}

#' Fill matrix of Gamma-region end points and Gamma values.
#'
#' @param gamma_mat The gamma matrix to fill.
#' @param gammas_x_sizes The value of `sum(gamma[i] * region_size[i])` to fill in.
#'     This value is used to later determine (in fxn `make_gamma_mats`) the
#'     mean gamma value across the whole genome, which is then used to make sure that
#'     the overall mean is 1.
#' @param seq_size_ Length of the focal sequence.
#' @param gamma_size_ Size of each Gamma region.
#' @param shape The shape parameter for the Gamma distribution from which
#'     Gamma values will be derived.
#' @param eng A random number generator.
#'
#'
#' @noRd
#'
NULL

#' Make matrices of Gamma-region end points and Gamma values for multiple sequences.
#'
#' @param seq_sizes Lengths of the sequences in the genome.
#' @param gamma_size_ Size of each Gamma region.
#' @param shape The shape parameter for the Gamma distribution from which
#'     Gamma values will be derived.
#'
#'
#' @noRd
#'
make_gamma_mats <- function(seq_sizes, gamma_size_, shape) {
    .Call(`_jackal_make_gamma_mats`, seq_sizes, gamma_size_, shape)
}

#' Check input Gamma matrices for proper # columns and end points.
#'
#' @param mats List of matrices to check.
#' @param seq_sizes Vector of sequences sizes for all sequences.
#'
#' @return A length-2 vector of potential error codes and the index (1-based indexing)
#'     to which matrix was a problem.
#'
#' @noRd
#'
check_gamma_mats <- function(mats, seq_sizes) {
    invisible(.Call(`_jackal_check_gamma_mats`, mats, seq_sizes))
}

#' Create XPtr to nested vector of PhyloTree objects from phylogeny information.
#'
#' @noRd
#'
phylo_info_to_trees <- function(genome_phylo_info) {
    .Call(`_jackal_phylo_info_to_trees`, genome_phylo_info)
}

#' Create XPtr to nested vector of PhyloTree objects from phylogeny information.
#'
#' Same as above, but chunked.
#'
#' @noRd
#'
phylo_info_to_trees_chunk <- function(genome_phylo_info) {
    .Call(`_jackal_phylo_info_to_trees_chunk`, genome_phylo_info)
}

#' Evolve all sequences in a reference genome.
#'
#' @noRd
#'
evolve_seqs <- function(ref_genome_ptr, sampler_base_ptr, phylo_info_ptr, gamma_mats, n_cores, show_progress) {
    .Call(`_jackal_evolve_seqs`, ref_genome_ptr, sampler_base_ptr, phylo_info_ptr, gamma_mats, n_cores, show_progress)
}

#' Same as above, but using chunks.
#'
#' @noRd
#'
evolve_seqs_chunk <- function(ref_genome_ptr, sampler_base_ptr, phylo_info_ptr, gamma_mats, n_cores, show_progress) {
    .Call(`_jackal_evolve_seqs_chunk`, ref_genome_ptr, sampler_base_ptr, phylo_info_ptr, gamma_mats, n_cores, show_progress)
}

#' Estimates equilibrium nucleotide frequencies from an input rate matrix.
#'
#' It does this by solving for Ï€Q = 0 by finding the left eigenvector of Q that
#' corresponds to the eigenvalue closest to zero.
#' This is only needed for the UNREST model.
#'
#' @inheritParams Q UNREST_rate_matrix_
#' @inheritParams pi_tcag UNREST_rate_matrix_
#'
#' @noRd
#'
NULL

#' Q matrix for rates for a given nucleotide using the UNREST substitution model.
#'
#' This function also fills in a vector of equilibrium frequencies for each nucleotide.
#' This calculation has to be done for this model only because it uses separate
#' values for each non-diagonal cell and doesn't use equilibrium frequencies for
#' creating the matrix.
#'
#'
#' @param Q Matrix of substitution rates for "T", "C", "A", and "G", respectively.
#'     Do not include indel rates here! Diagonal values are ignored.
#' @param pi_tcag Empty vector of equilibrium frequencies for for "T", "C", "A", and "G",
#'     respectively. This vector will be filled in by this function.
#' @param xi Overall rate of indels.
#'
#' @noRd
#'
NULL

#' Q matrix for rates for a given nucleotide using the TN93 substitution model.
#'
#' @noRd
#'
TN93_rate_matrix <- function(pi_tcag, alpha_1, alpha_2, beta) {
    .Call(`_jackal_TN93_rate_matrix`, pi_tcag, alpha_1, alpha_2, beta)
}

#' Q matrix for rates for a given nucleotide using the JC69 substitution model.
#'
#' JC69 is a special case of TN93.
#'
#' @noRd
#'
JC69_rate_matrix <- function(lambda) {
    .Call(`_jackal_JC69_rate_matrix`, lambda)
}

#' Q matrix for rates for a given nucleotide using the K80 substitution model.
#'
#' K80 is a special case of TN93.
#'
#' @noRd
#'
K80_rate_matrix <- function(alpha, beta) {
    .Call(`_jackal_K80_rate_matrix`, alpha, beta)
}

#' Q matrix for rates for a given nucleotide using the F81 substitution model.
#'
#' F81 is a special case of TN93.
#'
#' @noRd
#'
F81_rate_matrix <- function(pi_tcag) {
    .Call(`_jackal_F81_rate_matrix`, pi_tcag)
}

#' Q matrix for rates for a given nucleotide using the HKY85 substitution model.
#'
#' HKY85 is a special case of TN93.
#'
#' @noRd
#'
HKY85_rate_matrix <- function(pi_tcag, alpha, beta) {
    .Call(`_jackal_HKY85_rate_matrix`, pi_tcag, alpha, beta)
}

#' Q matrix for rates for a given nucleotide using the F84 substitution model.
#'
#' F84 is a special case of TN93.
#'
#' @noRd
#'
F84_rate_matrix <- function(pi_tcag, beta, kappa) {
    .Call(`_jackal_F84_rate_matrix`, pi_tcag, beta, kappa)
}

#' Q matrix for rates for a given nucleotide using the GTR substitution model.
#'
#' @noRd
#'
GTR_rate_matrix <- function(pi_tcag, abcdef) {
    .Call(`_jackal_GTR_rate_matrix`, pi_tcag, abcdef)
}

#' Same as above, but it only takes a matrix and indel rate, and outputs a list.
#'
#' The list is of the standardized `Q` and the calculated `pi_tcag`.
#' This is for use in R.
#'
#' @inheritParams Q UNREST_rate_matrix
#' @inheritParams xi UNREST_rate_matrix
#'
#' @noRd
#'
#'
UNREST_rate_matrix <- function(Q) {
    .Call(`_jackal_UNREST_rate_matrix`, Q)
}

#' PacBio sequence for reference object.
#'
#'
#' @noRd
#'
pacbio_ref_cpp <- function(ref_genome_ptr, out_prefix, compress, n_reads, n_cores, show_progress, read_chunk_size, prob_dup, scale, sigma, loc, min_read_len, read_probs, read_lens, max_passes, chi2_params_n, chi2_params_s, sqrt_params, norm_params, prob_thresh, prob_ins, prob_del, prob_subst) {
    invisible(.Call(`_jackal_pacbio_ref_cpp`, ref_genome_ptr, out_prefix, compress, n_reads, n_cores, show_progress, read_chunk_size, prob_dup, scale, sigma, loc, min_read_len, read_probs, read_lens, max_passes, chi2_params_n, chi2_params_s, sqrt_params, norm_params, prob_thresh, prob_ins, prob_del, prob_subst))
}

#' PacBio sequence for reference object.
#'
#'
#' @noRd
#'
pacbio_var_cpp <- function(var_set_ptr, out_prefix, compress, n_reads, n_cores, show_progress, read_chunk_size, variant_probs, prob_dup, scale, sigma, loc, min_read_len, read_probs, read_lens, max_passes, chi2_params_n, chi2_params_s, sqrt_params, norm_params, prob_thresh, prob_ins, prob_del, prob_subst) {
    invisible(.Call(`_jackal_pacbio_var_cpp`, var_set_ptr, out_prefix, compress, n_reads, n_cores, show_progress, read_chunk_size, variant_probs, prob_dup, scale, sigma, loc, min_read_len, read_probs, read_lens, max_passes, chi2_params_n, chi2_params_s, sqrt_params, norm_params, prob_thresh, prob_ins, prob_del, prob_subst))
}

#' Read a ms output file with newick gene trees and return the gene tree strings.
#'
#' @param ms_file File name of the ms output file.
#'
#' @return A vector of strings for each set of gene trees.
#'
#' @noRd
#'
read_ms_trees_ <- function(ms_file) {
    .Call(`_jackal_read_ms_trees_`, ms_file)
}

#' Read a ms output file with segregating sites and return the matrices of site info.
#'
#' @param ms_file File name of the ms output file.
#'
#' @return A vector of strings for each set of gene trees.
#'
#' @noRd
#'
coal_file_sites <- function(ms_file) {
    .Call(`_jackal_coal_file_sites`, ms_file)
}

#' Read VCF from a vcfR object.
#'
#'
#' @noRd
#'
read_vcfr <- function(reference_ptr, var_names, haps_list, seq_inds, pos, ref_seq) {
    .Call(`_jackal_read_vcfr`, reference_ptr, var_names, haps_list, seq_inds, pos, ref_seq)
}

#' Read a non-indexed fasta file to a \code{RefGenome} object.
#'
#' @param file_names File names of the fasta file(s).
#' @param cut_names Boolean for whether to cut sequence names at the first space.
#'     Defaults to \code{TRUE}.
#' @param remove_soft_mask Boolean for whether to remove soft-masking by making
#'    sequences all uppercase. Defaults to \code{TRUE}.
#'
#' @return Nothing.
#'
#' @noRd
#'
read_fasta_noind <- function(fasta_files, cut_names, remove_soft_mask) {
    .Call(`_jackal_read_fasta_noind`, fasta_files, cut_names, remove_soft_mask)
}

#' Read an indexed fasta file to a \code{RefGenome} object.
#'
#' @param file_name File name of the fasta file.
#' @param remove_soft_mask Boolean for whether to remove soft-masking by making
#'    sequences all uppercase. Defaults to \code{TRUE}.
#' @param offsets Vector of sequence offsets from the fasta index file.
#' @param names Vector of sequence names from the fasta index file.
#' @param lengths Vector of sequence lengths from the fasta index file.
#' @param line_lens Vector of sequence line lengths from the fasta index file.
#'
#' @return Nothing.
#'
#' @noRd
#'
#'
read_fasta_ind <- function(fasta_files, fai_files, remove_soft_mask) {
    .Call(`_jackal_read_fasta_ind`, fasta_files, fai_files, remove_soft_mask)
}

#' Write \code{RefGenome} to an uncompressed fasta file.
#'
#' @param file_name File name of output fasta file.
#' @param ref_genome_ptr An external pointer to a \code{RefGenome} C++ object.
#' @param text_width The number of characters per line in the output fasta file.
#'
#' @return Nothing.
#'
#' @noRd
#'
#'
write_fasta_fa <- function(file_name, ref_genome_ptr, text_width) {
    invisible(.Call(`_jackal_write_fasta_fa`, file_name, ref_genome_ptr, text_width))
}

#' Write \code{RefGenome} to a compressed fasta file.
#'
#' @inheritParams write_fasta_fa
#'
#' @return Nothing.
#'
#' @noRd
#'
write_fasta_gz <- function(file_name, ref_genome_ptr, text_width) {
    invisible(.Call(`_jackal_write_fasta_gz`, file_name, ref_genome_ptr, text_width))
}

#' Write `variants` to VCF file.
#'
#'
#' @noRd
#'
write_vcf_cpp <- function(out_prefix, compress, var_set_ptr, sample_matrix, testing) {
    invisible(.Call(`_jackal_write_vcf_cpp`, out_prefix, compress, var_set_ptr, sample_matrix, testing))
}

#' Template doing most of the work for writing to a VCF file.
#'
#' `T` should be `std::string`, `std::ofstream`, or `gzFile`, for the three
#' specializations of the `chunk_to_output` function above.
#'
#' @noRd
#'
NULL

#' Add mutations manually from R.
#'
#' This section applies to the next 3 functions.
#'
#' Note that all indices are in 0-based C++ indexing. This means that the first
#' item is indexed by `0`, and so forth.
#'
#' @param var_set_ptr External pointer to a C++ `VarSet` object
#' @param var_ind Integer index to the desired variant. Uses 0-based indexing!
#' @param seq_ind Integer index to the desired sequence. Uses 0-based indexing!
#' @param new_pos_ Integer index to the desired subsitution location.
#'     Uses 0-based indexing!
#'
#' @noRd
NULL

#' Function to print info on a `RefGenome`.
#'
#' Access `RefGenome` class's print method from R.
#'
#' @noRd
#'
print_ref_genome <- function(ref_genome_ptr) {
    invisible(.Call(`_jackal_print_ref_genome`, ref_genome_ptr))
}

#' Function to print info on a VarSet.
#'
#' Access `VarSet` class's print method from R.
#'
#' @noRd
#'
print_var_set <- function(var_set_ptr) {
    invisible(.Call(`_jackal_print_var_set`, var_set_ptr))
}

#' Make a RefGenome object from a set of sequences.
#'
#' Used for testing.
#'
#' @noRd
#'
make_ref_genome <- function(seqs) {
    .Call(`_jackal_make_ref_genome`, seqs)
}

#' Make a VarSet object from a RefGenome pointer and # variants.
#'
#' Used for testing.
#'
#'
#' @noRd
#'
make_var_set <- function(ref_genome_ptr, n_vars) {
    .Call(`_jackal_make_var_set`, ref_genome_ptr, n_vars)
}

view_ref_genome_nseqs <- function(ref_genome_ptr) {
    .Call(`_jackal_view_ref_genome_nseqs`, ref_genome_ptr)
}

view_var_set_nseqs <- function(var_set_ptr) {
    .Call(`_jackal_view_var_set_nseqs`, var_set_ptr)
}

view_var_set_nvars <- function(var_set_ptr) {
    .Call(`_jackal_view_var_set_nvars`, var_set_ptr)
}

view_ref_genome_seq_sizes <- function(ref_genome_ptr) {
    .Call(`_jackal_view_ref_genome_seq_sizes`, ref_genome_ptr)
}

#' See all sequence sizes in a VarGenome object within a VarSet.
#'
#' @noRd
#'
view_var_genome_seq_sizes <- function(var_set_ptr, var_ind) {
    .Call(`_jackal_view_var_genome_seq_sizes`, var_set_ptr, var_ind)
}

view_ref_genome_seq <- function(ref_genome_ptr, seq_ind) {
    .Call(`_jackal_view_ref_genome_seq`, ref_genome_ptr, seq_ind)
}

#' Function to piece together the strings for one sequence in a VarGenome.
#'
#' @noRd
#'
view_var_genome_seq <- function(var_set_ptr, var_ind, seq_ind) {
    .Call(`_jackal_view_var_genome_seq`, var_set_ptr, var_ind, seq_ind)
}

view_ref_genome <- function(ref_genome_ptr) {
    .Call(`_jackal_view_ref_genome`, ref_genome_ptr)
}

#' Function to piece together the strings for all sequences in a VarGenome.
#'
#' @noRd
#'
view_var_genome <- function(var_set_ptr, var_ind) {
    .Call(`_jackal_view_var_genome`, var_set_ptr, var_ind)
}

view_ref_genome_seq_names <- function(ref_genome_ptr) {
    .Call(`_jackal_view_ref_genome_seq_names`, ref_genome_ptr)
}

#' See all variant-genome names in a VarSet object.
#'
#' @noRd
#'
view_var_set_var_names <- function(var_set_ptr) {
    .Call(`_jackal_view_var_set_var_names`, var_set_ptr)
}

set_ref_genome_seq_names <- function(ref_genome_ptr, seq_inds, names) {
    invisible(.Call(`_jackal_set_ref_genome_seq_names`, ref_genome_ptr, seq_inds, names))
}

clean_ref_genome_seq_names <- function(ref_genome_ptr) {
    invisible(.Call(`_jackal_clean_ref_genome_seq_names`, ref_genome_ptr))
}

set_var_set_var_names <- function(var_set_ptr, var_inds, names) {
    invisible(.Call(`_jackal_set_var_set_var_names`, var_set_ptr, var_inds, names))
}

remove_ref_genome_seqs <- function(ref_genome_ptr, seq_inds) {
    invisible(.Call(`_jackal_remove_ref_genome_seqs`, ref_genome_ptr, seq_inds))
}

remove_var_set_vars <- function(var_set_ptr, var_inds) {
    invisible(.Call(`_jackal_remove_var_set_vars`, var_set_ptr, var_inds))
}

#' Turns a VarGenome's mutations into a list of data frames.
#'
#' Internal function for testing.
#'
#'
#' @noRd
#'
view_mutations <- function(var_set_ptr, var_ind) {
    .Call(`_jackal_view_mutations`, var_set_ptr, var_ind)
}

#' Turns a VarGenome's mutations into a list of data frames.
#'
#' Internal function for testing.
#'
#'
#' @noRd
#'
examine_mutations <- function(var_set_ptr, var_ind, seq_ind) {
    .Call(`_jackal_examine_mutations`, var_set_ptr, var_ind, seq_ind)
}

#' Faster version of table function to count the number of mutations in Gamma regions.
#'
#' @param gamma_ends Vector of endpoints for gamma regions
#' @param positions Vector of positions that you want to bin into gamma regions.
#'
#' @noRd
#'
table_gammas <- function(gamma_ends, positions) {
    .Call(`_jackal_table_gammas`, gamma_ends, positions)
}

#' @describeIn add_mutations Add a substitution.
#'
#' @inheritParams add_mutations
#' @param nucleo_ Character to substitute for existing one.
#'
#' @noRd
#'
add_substitution <- function(var_set_ptr, var_ind, seq_ind, nucleo_, new_pos_) {
    invisible(.Call(`_jackal_add_substitution`, var_set_ptr, var_ind, seq_ind, nucleo_, new_pos_))
}

#' @describeIn add_mutations Add an insertion.
#'
#' @inheritParams add_mutations
#' @param nucleos_ Nucleotides to insert at the desired location.
#'
#'
#' @noRd
#'
add_insertion <- function(var_set_ptr, var_ind, seq_ind, nucleos_, new_pos_) {
    invisible(.Call(`_jackal_add_insertion`, var_set_ptr, var_ind, seq_ind, nucleos_, new_pos_))
}

#' @describeIn add_mutations Add a deletion.
#'
#' @inheritParams add_mutations
#' @param size_ Size of deletion.
#'
#'
#' @noRd
#'
add_deletion <- function(var_set_ptr, var_ind, seq_ind, size_, new_pos_) {
    invisible(.Call(`_jackal_add_deletion`, var_set_ptr, var_ind, seq_ind, size_, new_pos_))
}

#' Get a rate for given start and end points of a VarSequence.
#'
#' @noRd
#'
test_rate <- function(start, end, var_ind, seq_ind, var_set_ptr, sampler_base_ptr, gamma_mat_) {
    .Call(`_jackal_test_rate`, start, end, var_ind, seq_ind, var_set_ptr, sampler_base_ptr, gamma_mat_)
}

using_openmp <- function() {
    .Call(`_jackal_using_openmp`)
}

