# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Merge a reference genome into a single sequence.
#'
#'
#' @param ref_genome_ptr An external pointer (R class \code{externalptr}) to a
#'     \code{RefGenome} class in C++ (the full class in C++ is
#'     \code{Rcpp::XPtr<RefGenome>}).
#'
#' @return Nothing. Changes are made in place.
#'
#' @name merge_sequences
#'
#' @noRd
#'
merge_sequences <- function(ref_genome_ptr) {
    invisible(.Call(`_gemino_merge_sequences`, ref_genome_ptr))
}

#' Filter reference genome sequences by size or for a proportion of total nucleotides.
#'
#'
#' @inheritParams ref_genome_ptr merge_sequences
#' @param min_seq_size Integer minimum sequence size to keep.
#'     Defaults to \code{0}, which results in this argument being ignored.
#' @param out_seq_prop Numeric proportion of total sequence to keep.
#'     Defaults to \code{0}, which results in this argument being ignored.
#'
#' @return Nothing. Changes are made in place.
#'
#' @name filter_sequences
#'
#' @noRd
#'
#'
filter_sequences <- function(ref_genome_ptr, min_seq_size = 0L, out_seq_prop = 0) {
    invisible(.Call(`_gemino_filter_sequences`, ref_genome_ptr, min_seq_size, out_seq_prop))
}

#' Create `RefGenome` pointer based on nucleotide equilibrium frequencies.
#'
#' Function to create random sequences for a new reference genome object.
#'
#' Note that this function will never return empty sequences.
#'
#' @param n_seqs Number of sequences.
#' @param len_mean Mean for the gamma distribution for sequence sizes.
#' @param len_sd Standard deviation for the gamma distribution for sequence sizes.
#'     If set to `<= 0`, all sequences will be the same length.
#' @param pi_tcag Vector of nucleotide equilibrium frequencies for
#'     "T", "C", "A", and "G", respectively.
#' @param n_cores Number of cores to use via OpenMP.
#'
#'
#' @return External pointer to a `RefGenome` C++ object.
#'
#' @noRd
#'
#' @examples
#'
#'
create_genome_ <- function(n_seqs, len_mean, len_sd, pi_tcag, n_cores) {
    .Call(`_gemino_create_genome_`, n_seqs, len_mean, len_sd, pi_tcag, n_cores)
}

#' Create random sequences as a character vector.
#'
#' This function is used internally for testing.
#'
#'
#' @inheritParams create_genome
#'
#' @return Character vector of sequence strings.
#'
#'
#' @noRd
#'
rando_seqs <- function(n_seqs, len_mean, len_sd = 0, pi_tcag = numeric(0), n_cores = 1L) {
    .Call(`_gemino_rando_seqs`, n_seqs, len_mean, len_sd, pi_tcag, n_cores)
}

#' Calculate how many bases come before a cleavage site.
#'
#'
#' @noRd
#'
get_precleavage_lens <- function(seqs) {
    .Call(`_gemino_get_precleavage_lens`, seqs)
}

#' Expand sequences for reverse complements and for non-specific nucleobases.
#'
#'
#' @noRd
#'
expand_seqs <- function(seqs) {
    .Call(`_gemino_expand_seqs`, seqs)
}

#' Internal C++ function to digest all sequences for all variants in a variant set.
#'
#'
#'
#' @param var_set_ptr An external pointer to a C++ \code{VarSet} object
#'     representing variants from the reference genome.
#' @inheritParams bind_sites digest_ref
#' @inheritParams len5s digest_ref
#' @param chunk_size The size of chunks to divide sequences into when digesting.
#' @param n_cores The number of cores to use for processing. Defaults to \code{1}.
#'
#' @return A list of lists, each sub-list containing multiple vectors representing
#'     the locations of cut sites for a given variant on a given sequence.
#'     Indexing the output list would be done as such:
#'     \code{output_list[[variant_index]][[sequence_index]][position_index]}.
#'
#' @noRd
#'
digest_var_set <- function(var_set_ptr, bind_sites, len5s, chunk_size, n_cores = 1L) {
    .Call(`_gemino_digest_var_set`, var_set_ptr, bind_sites, len5s, chunk_size, n_cores)
}

#' Internal C++ function to digest all sequences in a reference genome.
#'
#'
#'
#' @param ref_genome_ptr An external pointer to a C++ \code{RefGenome} object
#'     representing the reference genome.
#' @param bind_sites Vector of enzyme full recognition site(s).
#' @param len5s A vector of the numbers of characters of the prime5 sites for each
#'     recognition site.
#' @param chunk_size Size of chunks to break sequences into for processing.
#'     This value is ignored if it's set to zero.
#'     Ideally this is set to a value that results in a number of chunks divisible by
#'     the number of cores you're using, and is most useful when `n_cores` is greater
#'     than the number of scaffolds.
#'     Breaking into increasingly small chunks results in increasing overhead, so
#'     beware of making this argument very small.
#'     Reference genome sequences are not copied during this function, so using
#'     this argument for a reference genome does NOT decrease memory usage
#'     appreciably.
#'     Defaults to \code{0}.
#' @param n_cores The number of cores to use for processing. This value is ignored
#'     if the input reference genome is merged and \code{chunk_size == 0}.
#'     Defaults to \code{1}.
#'
#' @return A list of vectors, each vector representing the locations of cut sites
#'     on a given sequence.
#'     Indexing the output list would be done as such:
#'     \code{output_list[[sequence_index]][position_index]}.
#'
#' @noRd
#'
digest_ref <- function(ref_genome_ptr, bind_sites, len5s, chunk_size = 0L, n_cores = 1L) {
    .Call(`_gemino_digest_ref`, ref_genome_ptr, bind_sites, len5s, chunk_size, n_cores)
}

#' Illumina sequence for reference object.
#'
#'
#' @noRd
#'
illumina_ref_cpp <- function(ref_genome_ptr, paired, out_prefix, compress, n_reads, pcr_dups, n_cores, read_chunk_size, frag_len_shape, frag_len_scale, frag_len_min, frag_len_max, qual_probs1, quals1, ins_prob1, del_prob1, qual_probs2, quals2, ins_prob2, del_prob2, barcodes, instrument, run_number, flowcell_ID, lane, tile, x_pos, y_pos, read, is_filtered, control_number, sample_number) {
    invisible(.Call(`_gemino_illumina_ref_cpp`, ref_genome_ptr, paired, out_prefix, compress, n_reads, pcr_dups, n_cores, read_chunk_size, frag_len_shape, frag_len_scale, frag_len_min, frag_len_max, qual_probs1, quals1, ins_prob1, del_prob1, qual_probs2, quals2, ins_prob2, del_prob2, barcodes, instrument, run_number, flowcell_ID, lane, tile, x_pos, y_pos, read, is_filtered, control_number, sample_number))
}

#' Illumina sequence for reference object.
#'
#'
#' @noRd
#'
illumina_var_cpp <- function(var_set_ptr, paired, out_prefix, compress, n_reads, pcr_dups, n_cores, read_chunk_size, variant_probs, frag_len_shape, frag_len_scale, frag_len_min, frag_len_max, qual_probs1, quals1, ins_prob1, del_prob1, qual_probs2, quals2, ins_prob2, del_prob2, barcodes, instrument, run_number, flowcell_ID, lane, tile, x_pos, y_pos, read, is_filtered, control_number, sample_number) {
    invisible(.Call(`_gemino_illumina_var_cpp`, var_set_ptr, paired, out_prefix, compress, n_reads, pcr_dups, n_cores, read_chunk_size, variant_probs, frag_len_shape, frag_len_scale, frag_len_min, frag_len_max, qual_probs1, quals1, ins_prob1, del_prob1, qual_probs2, quals2, ins_prob2, del_prob2, barcodes, instrument, run_number, flowcell_ID, lane, tile, x_pos, y_pos, read, is_filtered, control_number, sample_number))
}

make_mutation_sampler_base <- function(Q, pi_tcag, insertion_rates, deletion_rates) {
    .Call(`_gemino_make_mutation_sampler_base`, Q, pi_tcag, insertion_rates, deletion_rates)
}

make_mutation_sampler_chunk_base <- function(Q, pi_tcag, insertion_rates, deletion_rates, chunk_size) {
    .Call(`_gemino_make_mutation_sampler_chunk_base`, Q, pi_tcag, insertion_rates, deletion_rates, chunk_size)
}

#' Fill matrix of Gamma-region end points and Gamma values.
#'
#' @param gamma_mat The gamma matrix to fill.
#' @param gammas_x_sizes The value of `sum(gamma[i] * region_size[i])` to fill in.
#'     This value is used to later determine (in fxn `make_gamma_mats`) the
#'     mean gamma value across the whole genome, which is then used to make sure that
#'     the overall mean is 1.
#' @param seq_size_ Length of the focal sequence.
#' @param gamma_size_ Size of each Gamma region.
#' @param shape The shape parameter for the Gamma distribution from which
#'     Gamma values will be derived.
#' @param eng A random number generator.
#'
#'
#' @noRd
#'
NULL

#' Make matrices of Gamma-region end points and Gamma values for multiple sequences.
#'
#' @param seq_sizes Lengths of the sequences in the genome.
#' @param gamma_size_ Size of each Gamma region.
#' @param shape The shape parameter for the Gamma distribution from which
#'     Gamma values will be derived.
#'
#'
#' @noRd
#'
make_gamma_mats <- function(seq_sizes, gamma_size_, shape) {
    .Call(`_gemino_make_gamma_mats`, seq_sizes, gamma_size_, shape)
}

#' Check input Gamma matrices for proper # columns and end points.
#'
#' @param mats List of matrices to check.
#' @param seq_sizes Vector of sequences sizes for all sequences.
#'
#' @return A length-2 vector of potential error codes and the index (1-based indexing)
#'     to which matrix was a problem.
#'
#' @noRd
#'
check_gamma_mats <- function(mats, seq_sizes) {
    invisible(.Call(`_gemino_check_gamma_mats`, mats, seq_sizes))
}

#' Create XPtr to nested vector of PhyloTree objects from phylogeny information.
#'
#' @noRd
#'
phylo_info_to_trees <- function(genome_phylo_info) {
    .Call(`_gemino_phylo_info_to_trees`, genome_phylo_info)
}

#' Create XPtr to nested vector of PhyloTree objects from phylogeny information.
#'
#' Same as above, but chunked.
#'
#' @noRd
#'
phylo_info_to_trees_chunk <- function(genome_phylo_info) {
    .Call(`_gemino_phylo_info_to_trees_chunk`, genome_phylo_info)
}

#' Evolve all sequences in a reference genome.
#'
#' @noRd
#'
evolve_seqs <- function(ref_genome_ptr, sampler_base_ptr, phylo_info_ptr, gamma_mats, n_cores, show_progress) {
    .Call(`_gemino_evolve_seqs`, ref_genome_ptr, sampler_base_ptr, phylo_info_ptr, gamma_mats, n_cores, show_progress)
}

#' Same as above, but using chunks.
#'
#' @noRd
#'
evolve_seqs_chunk <- function(ref_genome_ptr, sampler_base_ptr, phylo_info_ptr, gamma_mats, n_cores, show_progress) {
    .Call(`_gemino_evolve_seqs_chunk`, ref_genome_ptr, sampler_base_ptr, phylo_info_ptr, gamma_mats, n_cores, show_progress)
}

#' Estimates equilibrium nucleotide frequencies from an input rate matrix.
#'
#' It does this by solving for πQ = 0 by finding the left eigenvector of Q that
#' corresponds to the eigenvalue closest to zero.
#' This is only needed for the UNREST model.
#'
#' @inheritParams Q UNREST_rate_matrix_
#' @inheritParams pi_tcag UNREST_rate_matrix_
#'
#' @noRd
#'
NULL

#' Q matrix for rates for a given nucleotide using the UNREST substitution model.
#'
#' This function also fills in a vector of equilibrium frequencies for each nucleotide.
#' This calculation has to be done for this model only because it uses separate
#' values for each non-diagonal cell and doesn't use equilibrium frequencies for
#' creating the matrix.
#'
#'
#' @param Q Matrix of substitution rates for "T", "C", "A", and "G", respectively.
#'     Do not include indel rates here! Diagonal values are ignored.
#' @param pi_tcag Empty vector of equilibrium frequencies for for "T", "C", "A", and "G",
#'     respectively. This vector will be filled in by this function.
#' @param xi Overall rate of indels.
#'
#' @noRd
#'
NULL

#' Q matrix for rates for a given nucleotide using the TN93 substitution model.
#'
#' @noRd
#'
TN93_rate_matrix <- function(pi_tcag, alpha_1, alpha_2, beta) {
    .Call(`_gemino_TN93_rate_matrix`, pi_tcag, alpha_1, alpha_2, beta)
}

#' Q matrix for rates for a given nucleotide using the JC69 substitution model.
#'
#' JC69 is a special case of TN93.
#'
#' @noRd
#'
JC69_rate_matrix <- function(lambda) {
    .Call(`_gemino_JC69_rate_matrix`, lambda)
}

#' Q matrix for rates for a given nucleotide using the K80 substitution model.
#'
#' K80 is a special case of TN93.
#'
#' @noRd
#'
K80_rate_matrix <- function(alpha, beta) {
    .Call(`_gemino_K80_rate_matrix`, alpha, beta)
}

#' Q matrix for rates for a given nucleotide using the F81 substitution model.
#'
#' F81 is a special case of TN93.
#'
#' @noRd
#'
F81_rate_matrix <- function(pi_tcag) {
    .Call(`_gemino_F81_rate_matrix`, pi_tcag)
}

#' Q matrix for rates for a given nucleotide using the HKY85 substitution model.
#'
#' HKY85 is a special case of TN93.
#'
#' @noRd
#'
HKY85_rate_matrix <- function(pi_tcag, alpha, beta) {
    .Call(`_gemino_HKY85_rate_matrix`, pi_tcag, alpha, beta)
}

#' Q matrix for rates for a given nucleotide using the F84 substitution model.
#'
#' F84 is a special case of TN93.
#'
#' @noRd
#'
F84_rate_matrix <- function(pi_tcag, beta, kappa) {
    .Call(`_gemino_F84_rate_matrix`, pi_tcag, beta, kappa)
}

#' Q matrix for rates for a given nucleotide using the GTR substitution model.
#'
#' @noRd
#'
GTR_rate_matrix <- function(pi_tcag, abcdef) {
    .Call(`_gemino_GTR_rate_matrix`, pi_tcag, abcdef)
}

#' Same as above, but it only takes a matrix and indel rate, and outputs a list.
#'
#' The list is of the standardized `Q` and the calculated `pi_tcag`.
#' This is for use in R.
#'
#' @inheritParams Q UNREST_rate_matrix
#' @inheritParams xi UNREST_rate_matrix
#'
#' @noRd
#'
#'
UNREST_rate_matrix <- function(Q) {
    .Call(`_gemino_UNREST_rate_matrix`, Q)
}

#' Read a ms output file with newick gene trees and return the gene tree strings.
#'
#' @param ms_file File name of the ms output file.
#'
#' @return A vector of strings for each set of gene trees.
#'
#' @noRd
#'
read_ms_output_ <- function(ms_file) {
    .Call(`_gemino_read_ms_output_`, ms_file)
}

#' Read VCF from a vcfR object.
#'
#'
#' @noRd
#'
read_vcfr <- function(reference_ptr, var_names, haps_list, seq_inds, pos, ref_seq) {
    .Call(`_gemino_read_vcfr`, reference_ptr, var_names, haps_list, seq_inds, pos, ref_seq)
}

#' Read a non-indexed fasta file to a \code{RefGenome} object.
#'
#' @param file_name File name of the fasta file.
#' @param cut_names Boolean for whether to cut sequence names at the first space.
#'     Defaults to \code{TRUE}.
#' @param remove_soft_mask Boolean for whether to remove soft-masking by making
#'    sequences all uppercase. Defaults to \code{TRUE}.
#'
#' @return Nothing.
#'
#' @noRd
#'
read_fasta_noind <- function(fasta_file, cut_names, remove_soft_mask) {
    .Call(`_gemino_read_fasta_noind`, fasta_file, cut_names, remove_soft_mask)
}

#' Read an indexed fasta file to a \code{RefGenome} object.
#'
#' @param file_name File name of the fasta file.
#' @param remove_soft_mask Boolean for whether to remove soft-masking by making
#'    sequences all uppercase. Defaults to \code{TRUE}.
#' @param offsets Vector of sequence offsets from the fasta index file.
#' @param names Vector of sequence names from the fasta index file.
#' @param lengths Vector of sequence lengths from the fasta index file.
#' @param line_lens Vector of sequence line lengths from the fasta index file.
#'
#' @return Nothing.
#'
#' @noRd
#'
#'
read_fasta_ind <- function(fasta_file, fai_file, remove_soft_mask) {
    .Call(`_gemino_read_fasta_ind`, fasta_file, fai_file, remove_soft_mask)
}

#' Write \code{RefGenome} to an uncompressed fasta file.
#'
#' @param file_name File name of output fasta file.
#' @param ref_genome_ptr An external pointer to a \code{RefGenome} C++ object.
#' @param text_width The number of characters per line in the output fasta file.
#'
#' @return Nothing.
#'
#' @noRd
#'
#'
write_fasta_fa <- function(file_name, ref_genome_ptr, text_width) {
    invisible(.Call(`_gemino_write_fasta_fa`, file_name, ref_genome_ptr, text_width))
}

#' Write \code{RefGenome} to a compressed fasta file.
#'
#' @inheritParams write_fasta_fa
#'
#' @return Nothing.
#'
#' @noRd
#'
write_fasta_gz <- function(file_name, ref_genome_ptr, text_width) {
    invisible(.Call(`_gemino_write_fasta_gz`, file_name, ref_genome_ptr, text_width))
}

#' Add mutations manually from R.
#'
#' Note that all indices are in 0-based C++ indexing. This means that the first
#' item is indexed by `0`, and so forth.
#'
#' @param var_set_ptr External pointer to a C++ `VarSet` object
#' @param var_ind Integer index to the desired variant. Uses 0-based indexing!
#' @param seq_ind Integer index to the desired sequence. Uses 0-based indexing!
#' @param new_pos_ Integer index to the desired subsitution location.
#'     Uses 0-based indexing!
#'
#' @name add_mutations
NULL

#' Function to print info on a `RefGenome`.
#'
#' Access `RefGenome` class's print method from R.
#'
#' @noRd
#'
print_ref_genome <- function(ref_genome_ptr) {
    invisible(.Call(`_gemino_print_ref_genome`, ref_genome_ptr))
}

#' Function to print info on a VarSet.
#'
#' Access `VarSet` class's print method from R.
#'
#' @noRd
#'
print_var_set <- function(var_set_ptr) {
    invisible(.Call(`_gemino_print_var_set`, var_set_ptr))
}

#' Make a RefGenome object from a set of sequences.
#'
#' Used for testing.
#'
#' @noRd
#'
make_ref_genome <- function(seqs) {
    .Call(`_gemino_make_ref_genome`, seqs)
}

#' Make a VarSet object from a RefGenome pointer and # variants.
#'
#' Used for testing.
#'
#'
#' @noRd
#'
make_var_set <- function(ref_genome_ptr, n_vars) {
    .Call(`_gemino_make_var_set`, ref_genome_ptr, n_vars)
}

view_ref_genome_nseqs <- function(ref_genome_ptr) {
    .Call(`_gemino_view_ref_genome_nseqs`, ref_genome_ptr)
}

view_var_set_nseqs <- function(var_set_ptr) {
    .Call(`_gemino_view_var_set_nseqs`, var_set_ptr)
}

view_var_set_nvars <- function(var_set_ptr) {
    .Call(`_gemino_view_var_set_nvars`, var_set_ptr)
}

view_ref_genome_seq_sizes <- function(ref_genome_ptr) {
    .Call(`_gemino_view_ref_genome_seq_sizes`, ref_genome_ptr)
}

#' See all sequence sizes in a VarGenome object within a VarSet.
#'
#' @noRd
#'
view_var_genome_seq_sizes <- function(var_set_ptr, var_ind) {
    .Call(`_gemino_view_var_genome_seq_sizes`, var_set_ptr, var_ind)
}

view_ref_genome_seq <- function(ref_genome_ptr, seq_ind) {
    .Call(`_gemino_view_ref_genome_seq`, ref_genome_ptr, seq_ind)
}

#' Function to piece together the strings for one sequence in a VarGenome.
#'
#' @noRd
#'
view_var_genome_seq <- function(var_set_ptr, var_ind, seq_ind) {
    .Call(`_gemino_view_var_genome_seq`, var_set_ptr, var_ind, seq_ind)
}

view_ref_genome <- function(ref_genome_ptr) {
    .Call(`_gemino_view_ref_genome`, ref_genome_ptr)
}

#' Function to piece together the strings for all sequences in a VarGenome.
#'
#' @noRd
#'
view_var_genome <- function(var_set_ptr, var_ind) {
    .Call(`_gemino_view_var_genome`, var_set_ptr, var_ind)
}

view_ref_genome_seq_names <- function(ref_genome_ptr) {
    .Call(`_gemino_view_ref_genome_seq_names`, ref_genome_ptr)
}

#' See all variant-genome names in a VarSet object.
#'
#' @noRd
#'
view_var_set_var_names <- function(var_set_ptr) {
    .Call(`_gemino_view_var_set_var_names`, var_set_ptr)
}

set_ref_genome_seq_names <- function(ref_genome_ptr, seq_inds, names) {
    invisible(.Call(`_gemino_set_ref_genome_seq_names`, ref_genome_ptr, seq_inds, names))
}

set_var_set_var_names <- function(var_set_ptr, var_inds, names) {
    invisible(.Call(`_gemino_set_var_set_var_names`, var_set_ptr, var_inds, names))
}

remove_ref_genome_seqs <- function(ref_genome_ptr, seq_inds) {
    invisible(.Call(`_gemino_remove_ref_genome_seqs`, ref_genome_ptr, seq_inds))
}

remove_var_set_vars <- function(var_set_ptr, var_inds) {
    invisible(.Call(`_gemino_remove_var_set_vars`, var_set_ptr, var_inds))
}

#' Turns a VarGenome's mutations into a list of data frames.
#'
#' Internal function for testing.
#'
#'
#' @noRd
#'
view_mutations <- function(var_set_ptr, var_ind) {
    .Call(`_gemino_view_mutations`, var_set_ptr, var_ind)
}

#' Turns a VarGenome's mutations into a list of data frames.
#'
#' Internal function for testing.
#'
#'
#' @noRd
#'
examine_mutations <- function(var_set_ptr, var_ind, seq_ind) {
    .Call(`_gemino_examine_mutations`, var_set_ptr, var_ind, seq_ind)
}

#' Faster version of table function to count the number of mutations in Gamma regions.
#'
#' @param gamma_ends Vector of endpoints for gamma regions
#' @param positions Vector of positions that you want to bin into gamma regions.
#'
#'
#'
table_gammas <- function(gamma_ends, positions) {
    .Call(`_gemino_table_gammas`, gamma_ends, positions)
}

#' @describeIn add_mutations Add a substitution.
#'
#' @inheritParams add_mutations
#' @param nucleo_ Character to substitute for existing one.
#'
#'
add_substitution <- function(var_set_ptr, var_ind, seq_ind, nucleo_, new_pos_) {
    invisible(.Call(`_gemino_add_substitution`, var_set_ptr, var_ind, seq_ind, nucleo_, new_pos_))
}

#' @describeIn add_mutations Add an insertion.
#'
#' @inheritParams add_mutations
#' @param nucleos_ Nucleotides to insert at the desired location.
#'
#'
add_insertion <- function(var_set_ptr, var_ind, seq_ind, nucleos_, new_pos_) {
    invisible(.Call(`_gemino_add_insertion`, var_set_ptr, var_ind, seq_ind, nucleos_, new_pos_))
}

#' @describeIn add_mutations Add a deletion.
#'
#' @inheritParams add_mutations
#' @param size_ Size of deletion.
#'
#'
add_deletion <- function(var_set_ptr, var_ind, seq_ind, size_, new_pos_) {
    invisible(.Call(`_gemino_add_deletion`, var_set_ptr, var_ind, seq_ind, size_, new_pos_))
}

#' Get a rate for given start and end points of a VarSequence.
#'
#' @noRd
#'
test_rate <- function(start, end, var_ind, seq_ind, var_set_ptr, sampler_base_ptr, gamma_mat_) {
    .Call(`_gemino_test_rate`, start, end, var_ind, seq_ind, var_set_ptr, sampler_base_ptr, gamma_mat_)
}

#' Make pointer to object that simulates Illumina sequencing of a reference genome.
#'
#'
#' @noRd
#'
NULL

#' Make pointer to object that simulates Illumina sequencing of a variant set object.
#'
#'
#' @noRd
#'
NULL

#' Make pointer to object that simulates long-read sequencing of a reference genome.
#'
#'
#' @noRd
#'
NULL

#' Make pointer to object that simulates long-read sequencing of a reference genome.
#'
#'
#' @noRd
#'
NULL

using_openmp <- function() {
    .Call(`_gemino_using_openmp`)
}

